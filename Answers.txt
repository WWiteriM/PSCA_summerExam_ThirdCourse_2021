1.     Протокол HTTP, основные свойства HTTP, структура запроса и ответа, методы, статус (серии значений), заголовки, параметры. Протокол HTTPS. Понятие web-приложения, структура и принципы работы web-приложения. Понятие асинхронности.
HTTP-протокол – протокол передачи данных прикладного уровня, ассиметричный (сообщения от клиента к серверу и от сервера к клиенту разные). Всегда подразумевает пару request/response.
          Относится к протоколу, который не помнит своего состояния. В запросе и ответе нет никаких ссылок на предыдущий и последующий ответ и запрос.
  Каждый запрос-ответ – новый жизненный цикл HTTP (stateless протокол).
основные свойства
- версии HTTP/1.1 – действующий (текстовый), HTTP/2 – черновой (не распространен, бинарный);
-   два типа абонентов: клиент и сервер;
-   два типа сообщений: request и response;
-   от клиента к серверу – request;
-   от сервера к клиенту – response;
-   на один request всегда один response, иначе ошибка;
-   одному response всегда один request,  иначе ошибка;
-   TCP-порты: 80, 443;
-   для адресации используется URI или URN;
-   поддерживается W3C, описан в нескольких RFC.
HTTP заголовки — это часть HTTP сообщения, в которой содержатся различные параметры, которые используются для правильного построения web-страницы
-   General: общие заголовки, используются в запросах и ответах;
   
-   Request: используются только в запросах;
  

-   Response: используются только в ответах;
  

-   Entity: для сущности в ответах и запросах.
-   
 1. Request:
- метод;
- URI;
- версия протокола (HTTP/1.1);
- заголовки (пары: имя/заголовок);
- параметры (пары: имя/заголовок);
- расширение.


2. Response:
-   версия протокола (HTTP/1.1);
-   код состояния (1xx, 2xx, 3xx, 4xx, 5xx);
-   пояснение к коду состояния;
-   заголовки (пары: имя/заголовок);
-   расширение.
web-приложения - Веб-приложения — клиент-серверное приложение, в котором клиент взаимодействует с сервером по протоколу HTTP.
  

  

HTTPS — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS или устаревшего в 2015 году SSL. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443
 Uniform Resource Identifier – унифицированный идентификатор ресурса (документ, изображение, файл, служба, электронная почта, …).
Uniform Resource Location - унифицированный локатор ресурса, содержащий местонахождение ресурса и способ обращения (протокол) к ресурса, описывает множество URI.
Uniform Resource Name - унифицированное имя ресурса – URI, имя ресурса, не содержащее месторасположение и способ доступа к ресурсу. В будущем URN должен заменить URL (для решения проблем с перемещением ресурсов в Internet).
  

для взаимодействия между клиентом и сервером в соответствии с правилами (спецификацией, протоколом) должно быть установлено соединение; инициатором соединения всегда является клиент. 
  

операция называется асинхронной, если ее выполнение  осуществляется в 2 фазы:
1) заявка на исполнение;
2) получение результата;
при этом участвуют два механизма:
A-механизм, формирующий заявку и потом  получающий результат;
B-механизм, получающий заявку от A, исполняющий операцию и отправляющий результат A;
продолжительность выполнения операции B-механизмом, как правило, непредсказуемо;
в то время пока B-механизм исполняет операцию, А-механизм выполняет собственную работу.
Применение асинхронности не противоречит применению многопоточности.
Асинхронность в программировании — выполнение процесса в неблокирующем режиме системного вызова, что позволяет потоку программы продолжить обработку. 


 2.     Платформа Node.js, версии, назначение, основные свойства, структура, принципы работы, основные встроенные модули и их назначение, применение внешних модулей (пакетов).
Платформа Node.js - программная платформа для разработки  серверных web-приложений на языке JS/V8.
1. основные свойства:
-   основан на Chrome V8;
-   среда (контейнер) исполнения приложений на JavaScript;
-   поддерживает механизм асинхронности;
-   ориентирован на события;
-   однопоточный (код приложения исполняется только в одном потоке, один стек вызовов); обычно в серверах для каждого соединения создается свой поток, в Node.js все соединения обрабатываются в одном JS-потоке;
-   не блокирует выполнение кода при вводе/выводе (в файловой системе до 4х одновременно);
-   в состав Node.js входят инструменты: npm – пакетный менеджер; gyp - Python-генератор проектов; gtest – Google фреймворк для тестирования С++ приложений;  
-   использует библиотеки: V8 – библиотека V8 Engine, libuv – библиотека для абстрагирования неблокирующих операций ввода/вывода (представляет собой обертку над epoll, kqueue, IOCP); llhttp – легковесный парсер http-сообщений (написан на C и не выполняет никаких системных вызовов); c-ares - библиотека для работы с DNS; OpenSSL – библиотека для криптографии; zlib – сжатие и распаковка.
-   первая версия: 2009 г.;
-   стабильные версии: с 2015 г., Node.js 4.0.0;
-   основная сфера применения: разработка web-серверов;
версионирование: две ветки 14.x.x – версии длительной поддержки (LST, Long Term Support), 16.x.x – нестабильные версии, включающие последние разработки (Current).
  

  

 assert - Provides a set of assertion tests
buffer - To handle binary data
fs - To handle the file system
http - To make Node.js act as an HTTP server
querystring - To handle URL query strings
url - To parse URL strings
util - To access utility functions
const http = require("http");
  

 3.     HTTP-аутентификация (Basic, Digest, Forms).
Идентификация – заявление пользователя о себе.
Аутентификация – процедура проверки подлинности идентификации пользователя.
Авторизация - процедура проверки прав аутентифицированного пользователя. 
 HTTP Authentication: общая схема
  

HTTP Authentication: BASIC
Basic — наиболее простая схема, при которой username и password пользователя передаются в заголовке Authorization в незашифрованном виде (base64-encoded). Однако при использовании HTTPS (HTTP over SSL) протокола, является относительно безопасной.
При использовании данного вида аутентификации имя пользователя и пароль включаются в состав веб-запроса (HTTP POST или [GET]). Любой перехвативший пакет легко узнает секретную информацию. Даже если контент с ограниченным доступом не слишком важен, этот метод лучше не использовать, так как пользователь может применять один и тот же пароль на нескольких веб-сайтах. Также из недостатков парольной аутентификации следует отметить невысокий уровень безопасности — пароль можно подсмотреть, угадать, подобрать, сообщить посторонним лицам и т. д.
  
  



Согласно RFC 7235, этот realmпараметр зарезервирован для определения защитных пространств (набора страниц или ресурсов, где требуются учетные данные) и используется схемами аутентификации для указания области защиты.
 HTTP-Authenticate: Basic-аутентификация, npm install basic-auth 
  

  

Basic-аутентификация, npm install passport, npm install passport-http 
  

  

  

  

 HTTP Authentication: Digest
Дайджест-аутентификация доступа — один из общепринятых методов, используемых веб-сервером для обработки учетных данных пользователя веб-браузера. Аналогичный метод используется в рамках VoIP-протокола SIP для аутентификации сервером обращения со стороны клиента, т.е. оконечного терминала. Данный метод отправляет по сети хеш-сумму логина, пароля, адреса сервера и случайных данных, и предоставляет больший уровень защиты, чем базовая аутентификация, при которой данные отправляются в открытом виде.
Технически, аутентификация по дайджесту представляет собой применение криптографической хеш-функции MD5 к секрету пользователя с использованием случайных значений для затруднения криптоанализа и предотвращения replay-атак. Работает на уровне протокола HTTP.


Digest — challenge-response-схема, при которой сервер посылает уникальное значение nonce, а браузер передает MD5 хэш пароля пользователя, вычисленный с использованием указанного nonce. Более безопасная альтернатив Basic схемы при незащищенных соединениях, но подвержена man-in-the-middle attacks (с заменой схемы на basic). Кроме того, использование этой схемы не позволяет применить современные хэш-функции для хранения паролей пользователей на сервере.


  

  

  

  

  

  

 HTTP-Authenticate: digest-аутентификация, npm install passport, npm install passport-http.
  

 Forms Authentication: нет стандарта, но применяется
Для этого протокола нет определенного стандарта, поэтому все его реализации специфичны для конкретных систем, а точнее, для модулей аутентификации фреймворков разработки.
Работает это по следующему принципу: в веб-приложение включается HTML-форма, в которую пользователь должен ввести свои username/password и отправить их на сервер через HTTP POST для аутентификации. В случае успеха веб-приложение создает session token, который обычно помещается в browser cookies. При последующих веб-запросах session token автоматически передается на сервер и позволяет приложению получить информацию о текущем пользователе для авторизации запроса.
  

 Forms-Authenticate: пример
  



 4.     Протокол HTTPS. Протокол TSL. Сертификаты. Взаимодействие центра сертификации и владельца защищенного ресурса.
HTTPS – это защищенный протокол передачи гипертекста, который обеспечивает зашифрованную передачу данных между сервером сайта и его пользователями. В качестве инструментов шифрования в этом стандарте используются протоколы SSL/TLS, защищающие информацию методами криптографии.
Протокол TLS (transport layer security) основан на протоколе SSL (Secure Sockets Layer), изначально разработанном в Netscape для повышения безопасности электронной коммерции в Интернете. Протокол SSL был реализован на application-уровне, непосредственно над TCP (Transmission Control Protocol), что позволяет более высокоуровневым протоколам (таким как HTTP или протоколу электронной почты) работать без изменений. Если SSL сконфигурирован корректно, то сторонний наблюдатель может узнать лишь параметры соединения (например, тип используемого шифрования), а также частоту пересылки и примерное количество данных, но не может читать и изменять их.


Протокол TLS предназначен для предоставления трёх услуг всем приложениям, работающим над ним, а именно: шифрование, аутентификацию и целостность. Технически, не все три могут использоваться, однако на практике, для обеспечения безопасности, как правило используются все три:
* Шифрование – сокрытие информации, передаваемой от одного компьютера к другому;
* Аутентификация – проверка авторства передаваемой информации;
* Целостность – обнаружение подмены информации подделкой.


Certificate Authentication: TSL.
Сертификат X.509: стандартный формат хранения и транспортировки атрибутов безопасности; главное – открытый ключ; сертификаты выдают центры сертификации (Certificate Authority, CA). http://www.thwate.com, http://www.Verysign.com; если это intranet, то можно использовать Certificate Server Active Directory; сертификат содержит: имя держателя, адрес, серийный номер сертификата, даты проверки, открытый ключ держателя.
  

 Сертификат X.509: форматы файлов сертификатов X.509
  

 TLS: обеспечивает конфиденциальность; обеспечивает целостность (обнаружение подмены); аутентификация узлов (проверка подлинности источника сообщений); последняя версия 1.3; поверх потокового надежного соединения (для ненадежной передачи есть DTSL);
TLS: handshake
  

  

  

Взаимодействие клиента с центром сертификации


 5.     Протокол WebSocket, основные свойства, процедура установки соединения. WebSockets API.
протокол полнодуплексной(дуплексной) связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером через постоянное соединение.
  

  

Спецификация WebSocket определяет API для установки соединения между веб-браузером и сервером, основанного на «сокете». Проще говоря, это — постоянное соединение между клиентом и сервером, пользуясь которыми клиент и сервер могут отправлять данные друг другу в любое время.
Клиент устанавливает соединение, выполняя процесс так называемого рукопожатия WebSocket. Этот процесс начинается с того, что клиент отправляет серверу обычный HTTP-запрос. В этот запрос включается заголовок Upgrade, который сообщает серверу о том, что клиент желает установить WebSocket-соединение.
// Создаём новое WebSocket-соединение. var socket = new WebSocket('ws://websocket.example.com');
URL, применяемый для WebSocket-соединения, использует схему ws. Кроме того, имеется схема wss для организации защищённых WebSocket-соединений, что является эквивалентом HTTPS.
Если сервер поддерживает протокол WebSocket, он согласится перейти на него и сообщит об этом в заголовке ответа Upgrade.
Теперь, после завершения фазы рукопожатия, исходное HTTP-соединение заменяется на WebSocket-соединение, которое использует то же самое базовое TCP/IP-соединение. В этот момент и клиент и сервер могут приступать к отправке данных.
В любой момент после процедуры рукопожатия, либо клиент, либо сервер, может решить отправить другой стороне ping-сообщение. Получая такое сообщение, получатель должен отправить, как можно скорее, pong-сообщение. Это и есть heartbeat-сообщения. Их можно использовать для того, чтобы проверить, подключён ли ещё клиент к серверу.
  

Описания заголовков:
GET, Host
Стандартные HTTP-заголовки из URL запроса
Upgrade, Connection
Указывают, что браузер хочет перейти на websocket.
Origin
Протокол, домен и порт, откуда отправлен запрос.
Sec-WebSocket-Key
Случайный ключ, который генерируется браузером: 16 байт в кодировке Base64.
Sec-WebSocket-Version
Версия протокола. Текущая версия: 13.
Все заголовки, кроме GET и Host, браузер генерирует сам, без возможности вмешательства JavaScript.
  

When the server receives the handshake request, it should send back a special response that indicates that the protocol will be changing from HTTP to WebSocket
Pings and Pongs: The Heartbeat of WebSockets
At any point after the handshake, either the client or the server can choose to send a ping to the other party. When the ping is received, the recipient must send back a pong as soon as possible. You can use this to make sure that the client is still connected, for example.
To close a connection either the client or server can send a control frame with data containing a specified control sequence to begin the closing handshake
https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers


WebSockets API –
Socket.IO – для людей
Ws – 
Simple server
 const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });
wss.on('connection', function connection(ws) {
  ws.on('message', function incoming(message) {
        console.log('received: %s', message);
  });
  ws.send('something');
});
  

  

 6.     Применение СУБД Redis. Основные принципы работы.
Redis (расшифровывается как Remote Dictionary Server) – это быстрое хранилище данных типа «ключ‑значение» в памяти с открытым исходным кодом для использования в качестве базы данных, кэша, брокера сообщений или очереди.
Все данные в Redis хранятся в памяти, а не на дисках или твердотельных накопителях, как в других базах данных. Поскольку Redis, как и другие хранилища данных в памяти, не нуждается в доступе к диску, это исключает задержки, связанные с поиском, и обеспечивает доступ к данным за микросекунды. В число возможностей Redis входит поддержка разнообразных структур данных, обеспечение высокой доступности, работа с геопространственными данными, создание скриптов Lua, проведение транзакций, постоянное хранение данных на диске и поддержка кластеров. Все это упрощает создание приложений, работающих в режиме реального времени в масштабе всего Интернета.
 Redis (REmote DIctionary Server): noSQL СУБД с открытым кодом (BSD-лицензия), Redis Labs, Сальваторе Санфилиппо:
-   хранилище данных в оперативной памяти;
-   для кэша;
-   для посредника сообщений;
-   структуры данных: строки, хэш-таблицы, списки, наборы, отсортированные наборы, растровые изображения, геопространственные индексы, HyperLogLog;
-   СУБД ориентирована на быстрое выполнение атомарных операций (до 100тыс. set/get-операций);
-   механизм снимков для асинхронного сохранения (с потерями);
-   механизм упреждающей записи;  
-   написана на ANSI С;
-   последняя стабильная версия: 6;
-   API: C, C++, C#, Java, JavaScript, Python, … ;
-   работает только под Linux.
 
HyperLogLog - это алгоритм для задачи, связанной с подсчетом, аппроксимирующей количество различных элементов в мультимножестве. Для вычисления точного количества элементов мультимножества требуется объем памяти, пропорциональный количеству элементов, что нецелесообразно для очень больших наборов данных.


 Redis: npm redis, соединение, завершение, события
  

  
  

 Redis: set, callback, NX, XX


  

 Redis: get
  

  

 Redis: incr, incrby, decr, decrby, getset
 Redis: incrbyfloat, getset 
 Redis: mset, mget - вставка, получение нескольких полей за раз
 Redis: del, exists  
 Redis: hset, hget, hlen, hdel, hexists, hgetall, hvals, hmset, hmget, hincrby, hincrbyfloat 
hset - Устанавливает поле в хэше, хранящемся в ключе к значению. Если ключ не существует, создается новый ключ, содержащий хэш. Если поле уже существует в хэше, оно перезаписывается. 
hget - Получает поле в хэша, хранящемся в ключе к значению 
Hmset - Устанавливает для нескольких полей их соответствующие значения в хэше, хранящемся в ключе. Эта команда перезаписывает любые указанные поля, уже существующие в хэше. Если ключ не существует, создается новый ключ, содержащий хэш.    


 Redis: канал (channel) – это абстракция, используемая для быстрого обмена данными между издателем и подписчиком.
  

 Redis: publish, subscribe
  

  

Команды Redis с описанием и примером


7. Применение пакета Sequelize. Основные принципы работы (подключение, объявление моделей, конфигурация, подход Code First, поисковые методы, фильтрация, пагинация, сортировка, группировка). Пример.


Sequelize - npm-пакет, реализующий ORM-технологию.
Object Relational Mapping - технология программирования, которая позволяет работать с SQL-базой данных, как с набором программных объектов.
ORM – это методика или техника программирования, предназначенная для преобразования между несовместимыми типами данных в объектно-ориентированных языках программирования. Суть заключается в том, что создается некая абстракция - “виртуальная объектная база”, запросы к которой, преобразуются в SQL команды, т.е. больше не нужно писать SQL-запросы к базе данных вручную.
ORM фреймворк может быть написан на каком-либо объектно-ориентированном языке и представлять обертку над некой реляционной базой данных. Классы будут соответствовать таблицам в базе, а экземпляры этих классов – конкретным строкам таблицы.
Преимущества
·           Независимость от вида базы данных
Это, пожалуй, главнейшая особенность и преимущество использования ORM в приложении. Так как нет необходимости писать специфический код под конкретный вид базы данных.
·           Моделирование предметной области
При использовании ORM для построения приложения, бизнес-логика приложения работает с объектами языка, а не с самой структурой базы данных. Это возможно благодаря соответствию между бизнес-моделью и самой базой данных.
·           Меньше кода и больше эффективности
ORM добавляет дополнительный слой абстракции, который позволяет разработчикам сконцентрироваться на их бизнес-логике, не отвлекаясь на создание сложных запросов к базе данных. Это приводит к сокращению количества необходимого для написания кода и увеличивает продуктивность разработчика.
·           Управление зависимостями
ORM предоставляет свободное управление зависимостями в базе данных. Связанные объекты загружаются автоматически, когда вызов методов преобразуется в соответствующий SQL запрос.
·           Параллелизм, кэширование и транзакции
ORM поддерживает возможность параллельной работы, позволяя нескольким пользователям одновременно изменять один и тот же объект.
Другая особенность – объекты могут быть сохранены в кэше, сокращая нагрузку на базу и в целом увеличивая скорость работы приложения.
Изменения, вносимые в объект, могут быть ограничены в рамках данной транзакции, которая может быть сохранена или возвращена обратно в первоначальное состояние. В каждый момент времени могут быть активными множество транзакций, но все эти транзакции изолированы друг от друга.
Недостатки
·           Накладные расходы
ORM фреймворк добавляет слой абстракции, ускоряющий процесс разработки и снижающий сложность создания конечного продукта. Однако, ничто не проходит даром – приложение начинает потреблять больше памяти, и нагрузка на процессор также увеличивается.
·           Производительность
Некоторые операции, такие как массовая вставка, обновление, удаление и т.д., медленнее, когда выполняются посредством ORM. Поэтому, в таких случаях лучше использовать чистый SQL.
·           Поверхностное знание SQL
Несмотря на то, что ORM облегчает жизнь, это часто приводит к тому, что разработчики не очень стремятся учить SQL или разбираются в нем слабо.
Object Document Mapping - технология программирования, которая сопоставляет объекты с документной базой данных(MongoDB).
Подключение:   
Tedious – протокол прикладного уровня, который использует mssql поверх TCP.


Объявление моделей:
1. Model.init
  

________________




2. sequelize.define
  

Конфигурация: 
sequelize - экземпляр подключения. 
TableName - имя таблицы.
Timestamps – false: отслеживает изменение в таблице(дополнительное поле будет создано или нет).
references - внешний ключ. 
  



User.sync() - создает таблицу, если она не существует(ничего не делает, если она существует).
User.sync({force: true}) - создает таблицу, сначала отбрасывая ее, если она уже существует.
User.sync({alter: true}) - проверяет текущее состояние таблицы в базе данных, а затем выполняет необходимые изменения в таблице, чтобы соответствовала модели.


Code-First  означает написание классов сущностей модели данных, которые мы будем использовать в нашем проекте, и позволить ORM сгенерировать базу данных.


select
  

select XX, YY as ’VVV’
  

select COUNT(XX) as ’VVV’
  



select …where 
  





select … from table where field1 = … OR field1 = …
  

Sequelize.Op.and = AND
Sequelize.Op.gt = “>”
Sequelize.Op.lt = “<”


select … order by
  



select … group by
  

 8.     Применение пакета Sequelize. Основные принципы работы (добавление, изменение, удаление строк в таблице, raw query). Пример.
insert - строку, которую вставили
  

        
        update - возвращает количество обновленных строк
  



delete - возвращает 1, если успех, и 0 в противном случае        
  



raw query - самописные запросы, когда запрос очень сложный
2 способа передачи параметров:
* : - поименованный
* ? - порядковый номер
  

  

 9.     Применение пакета Sequelize. Основные принципы работы (scopes, хуки, соединения, отношения между таблицами, транзакции). Пример.
Scopes используются, чтобы повторно использовать код,  определены в модели и могут быть объектами поиска или функциями.
  

  

Хуки (также известные как события жизненного цикла) - это функции, которые вызываются до и после выполнения вызовов в sequelize. Например, если вы хотите всегда устанавливать значение для модели перед ее сохранением, вы можете добавить beforeUpdate.
Триггеры представляют собой функции, которые выполняются (если они определены) до/после/во время действий с данными. Список самых популярных триггеров в порядке их выполнения:
beforeValidate(данные, опции) - выполняется перед валидацией;
afterValidate(данные, опции) или validationFailed(данные, опции, ошибка) - выполняется после успешной или неуспешной проверки валидации соответственно;
beforeCreate(данные, опции) - вызывается перед созданием записи;
beforeDestroy(данные, опции) - выполняется перед удалением записи;
beforeUpdate(данные, опции) - вызывается перед обновлением записи;
beforeSave(данные, опции) - вызывается перед сохранением записи;
afterCreate(данные, опции) - вызывается после создания записи;
afterDestroy(данные, опции) - выполняется после удаления записи;
afterUpdate(данные, опции) - вызывается после обновления записи;
afterSave(данные, опции) - вызывается после сохранения записи.
2 вида хуков: локальные и глобальные. Сперва вызываются локальные, а потом глобальные.
Глобальные хуки - это хуки, которые запускаются для всех моделей. Они могут определять поведение, которое вы хотите для всех ваших моделей. Они могут быть определены двумя способами, которые имеют несколько различную семантику:
  

 Это добавляет хук по умолчанию ко всем моделям, который запускается, если модель не определяет свою собственную beforeCreate хук
  

  

Этот хук всегда запускается, независимо от того, указывает ли модель свой собственный хук или нет beforeCreate хук.
Постоянные хук также могут быть определены в опциях, переданных конструктору Sequelize
  

Обратите внимание, что вышеприведенное не совпадает с крючками по умолчанию, упомянутыми выше. Этот вариант использует define опцию конструктора. А вот этот-нет.


select … inner join 
  

select … left outer join


  

Создание связей между таблицами осуществляется с использованием моделей. Рассмотрим установление следующих типов связей:
·       один к одному;
·       один ко многим;
·       многие ко многим.
Эта A.hasOne(B) связь означает, что существует взаимно однозначное отношение между A и B, причем внешний ключ определяется в целевой модели (B).
Эта A.belongsTo(B) связь означает, что существует взаимно однозначное отношение между A и B, причем внешний ключ определяется в исходной модели (A).
A.hasMany(B) Ассоциация означает, что существует отношение "один ко многим" Между A и B, причем внешний ключ определяется в целевой модели (B).
Эти три вызова вызовут Sequelize для автоматического добавления внешних ключей к соответствующим моделям (если они уже не присутствуют).
A.belongsToMany(B, { through: 'C' }) Ассоциация означает, что существует отношение "многие ко многим" между A и B, используя таблицу C в качестве соединительной таблицы, которая будет иметь внешние ключи (aId bId например, и). Sequelize автоматически создаст эту модель C (если она уже не существует) и определит для нее соответствующие внешние ключи.
Sequelize по умолчанию не использует транзакции. Однако для готового к производству использования Sequelize вам определенно следует настроить Sequelize для использования транзакций.
Sequelize поддерживает два способа использования транзакций:
·       Неуправляемые транзакции: фиксация и откат транзакции должны выполняться пользователем вручную (путем вызова соответствующих методов Sequelize).
·       Управляемые транзакции: Sequelize автоматически откатит транзакцию, если возникнет какая-либо ошибка, или зафиксирует транзакцию в противном случае. Кроме того, если CLS (локальное хранилище продолжения) включен, все запросы в обратном вызове транзакции автоматически получат объект транзакции.
 transaction… (unmanaged)
  

10.         Пакет Express. Основные принципы работы. Маршрутизация, промежуточные обработчики, обработка ошибок. Пример.
Express - это фреймворк для Node.js, который реализовывает слой функций, необходимых для создания эффективных приложений и API. Его использование значительно сокращает написание кода, а, значит, уменьшается затрачиваемое на разработку время.
Фре́ймворк — программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.
Node.js Express устанавливается через пакетный менеджер npm.
Node.js Express имеет готовые функции обработки HTTP запросов, причем для каждого HTTP метода имеется своя функция, что особенно удобно при создании REST API. И это далеко не единственная причина использования Express.
При обработке запросов фреймворк Express опирается на систему маршрутизации. В приложении определяются маршруты, а также обработчики этих маршрутов. Если запрос соответствует определенному маршруту, то вызывается для обработки запроса соответствующий обработчик.
Маршрутизация определяет, как приложение отвечает на клиентский запрос к конкретному адресу (конечной точке), которым является URI (или путь), и определенному методу запроса HTTP (GET, POST и т.д.).
Каждый маршрут может иметь одну или несколько функций обработки, которые выполняются при сопоставлении маршрута.
Определение маршрута имеет следующую структуру:
  

С помощью класса express.Router можно создавать модульные, монтируемые обработчики маршрутов. Экземпляр Router представляет собой комплексную систему промежуточных обработчиков и маршрутизации; по этой причине его часто называют “мини-приложением”.
В приведенном ниже примере создается маршрутизатор в виде модуля, в него загружается функция промежуточной обработки, определяется несколько маршрутов, и модуль маршрутизатора монтируется в путь в основном приложении.
  

  

Функции промежуточной обработки (middleware) - это функции, имеющие доступ к объекту запроса (req), объекту ответа (res) и к следующей функции промежуточной обработки в цикле “запрос-ответ” приложения. Следующая функция промежуточной обработки, как правило, обозначается переменной next.
Функции промежуточной обработки могут выполнять следующие задачи:
* Выполнение любого кода.
* Внесение изменений в объекты запросов и ответов.
* Завершение цикла “запрос-ответ”.
* Вызов следующего промежуточного обработчика из стека.
Если текущая функция промежуточной обработки не завершает цикл “запрос-ответ”, она должна вызвать next() для передачи управления следующей функции промежуточной обработки. В противном случае запрос зависнет.
Ниже представлены элементы вызова функции промежуточного обработчика:
  

Для того чтобы загрузить функцию промежуточного обработчика вызовите app.use() с указанием соответствующей функции.
Порядок загрузки промежуточных обработчиков очень важен: функции промежуточных обработчиков, загруженные первыми, выполняются в первую очередь.
Приложение Express может использовать следующие типы промежуточных обработчиков:
* Промежуточный обработчик уровня приложения
* Промежуточный обработчик уровня маршрутизатора
* Промежуточный обработчик для обработки ошибок
* Встроенные промежуточные обработчики
* Промежуточные обработчики сторонних поставщиков ПО
Промежуточный обработчик уровня приложения с экземпляром объекта приложения, воспользовавшись функциями app.use() и app.METHOD(), где METHOD - метод HTTP запроса, обрабатываемый функцией промежуточной обработки (например, GET, PUT или POST) в нижнем регистре
  

Обработчики маршрутов позволяют определить несколько маршрутов для одного пути. В приведенном ниже примере определено два маршрута для запросов GET, адресованных ресурсам в пути /user/:id. Второй маршрут не создает никаких неудобств, но его вызов никогда не будет выполнен, поскольку первый маршрут завершает цикл “запрос-ответ”.
Обработка ошибок
Функции промежуточного обработчика для обработки ошибок определяются так же, как и другие функции промежуточной обработки, но с указанием для функции обработки ошибок не трех, а четырех аргументов: (err, req, res, next).
  

Промежуточный обработчик для обработки ошибок должен быть определен последним, после указания всех app.use() и вызовов маршрутов;
В целях упорядочения (и для фреймворков более высокого уровня) можно определить несколько функций промежуточной обработки ошибок, точно так же, как это допускается для обычных функций промежуточной обработки.
11.         Пакет Express. Основные принципы работы. Статические файлы. Отдача статики. Кэширование на стороне клиента.
Express - это фреймворк для Node.js, который реализовывает слой функций, необходимых для создания эффективных приложений и API. Его использование значительно сокращает написание кода, а, значит, уменьшается затрачиваемое на разработку время.
Фре́ймворк — программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.
Node.js Express устанавливается через пакетный менеджер npm.
Node.js Express имеет готовые функции обработки HTTP запросов, причем для каждого HTTP метода имеется своя функция, что особенно удобно при создании REST API. И это далеко не единственная причина использования Express.
При обработке запросов фреймворк Express опирается на систему маршрутизации. В приложении определяются маршруты, а также обработчики этих маршрутов. Если запрос соответствует определенному маршруту, то вызывается для обработки запроса соответствующий обработчик.
Статические файлы: файлы, расположенные на стороне сервера и предназначенные для считывания их без изменения с помощью HTTP GET-запроса по имени ресурса, включающего имя файла
express.static(root, [options])
Единственной встроенной функцией промежуточной обработки в Express является express.static. Эта функция основана на serve-static и отвечает за предоставление статических ресурсов приложения Express.
Аргумент root указывает на корневой каталог, из которого предоставляются статические ресурсы.
Необязательный объект options может содержать следующие свойства:
  

Для каждого приложения допускается наличие нескольких статических каталогов:
  

Cache-control используется для задания инструкций кэширования как для запросов, так и для ответов.
ETag (или entity tag) — один из механизмов кэширования в HTTP. По сути это идентификатор, который присваивается файлу сервером для последующей проверки
Last-Modified в ответе HTTP содержит дату и время, в которую, по мнению удаленного сервера, запрашиваемый ресурс был изменен.
If-Modified-Since делает запрос условным: сервер отправит обратно запрошенный ресурс с статусом 200, только если он был изменен после указанной даты. Если запрос не был изменен после указанной даты, ответ будет 304 без какого-либо тела; заголовок Last-Modified при этом будет содержать дату последней модификации. If-None-Match Для методов GET и HEAD сервер отправляет запрошенный ресурс только в том случае, если он соответствует одному из перечисленных ETags. Для PUT и других небезопасных методов он будет загружать только ресурс в этом случае.


12.         Пакет Express. Основные принципы работы. Объекты запроса и ответа.
Express - это фреймворк для Node.js, который реализовывает слой функций, необходимых для создания эффективных приложений и API. Его использование значительно сокращает написание кода, а, значит, уменьшается затрачиваемое на разработку время.
Node.js Express устанавливается через пакетный менеджер npm.
Node.js Express имеет готовые функции обработки HTTP запросов, причем для каждого HTTP метода имеется своя функция, что особенно удобно при создании REST API. И это далеко не единственная причина использования Express.
Метод use() используется для создания промежуточных обработчиков - Middleware.
Фре́ймворк — программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проек та.
Объект Request содержит информацию о запросе. Объект представляет собой HTTP - запрос и имеет свойства для строки запроса запроса, параметров, тела, HTTP-заголовков и т.д. 


Свойство
	Описание
	.app
	содержит ссылку на объект приложения
	.baseUrl
	содержит ссылку на экземпляр маршрутизатора (express.Router())
	.body
	содержит данные, помещенные в тело запроса (должны быть разобраны (parsed) и заполнены (populated) перед использованием)
	.cookies
	содержит куки, установленные в запросе (требуется промежуточное программное обеспечение (далее — ППО) cookie-parser)
	.hostname
	название хоста сервера
	.ip
	IP-адрес сервера
	.method
	метод запроса
	.params
	объект с именованными параметрами запроса (например, при запросе к /users/:id, id будет записано в req.params.id)
	.path
	URL запроса
	.protocol
	протокол запроса
	.query
	объект с параметрами строки запроса (например, при запросе к /search?name=john, john будет записано в req.query.name)
	.secure
	содержит true, если запрос является безопасным (если используется HTTPS)
	.signedCookies
	содержит подписанные куки (требуется ППО cookie-parser)
	.xhr
	содержит true, если запрос — это XMLHttpRequest
	

Объект Response представляет собой HTTP-ответ. Методы объекта response (res) в следующей таблице могут отправить ответ клиенту и завершить цикл ответа запроса. Если ни один из них не будет вызван из обработчика маршрута, клиентский запрос останется висеть.


Method
	Description
	res.download()
	Запросите файл для загрузки.
	res.end()
	Завершите процесс реагирования.
	res.json()
	Отправьте ответ JSON.
	res.redirect()
	Перенаправление запроса.
	res.render()
	Отрисовка шаблона представления.
	res.send()
	Отправьте ответ различного типа.
	res.sendFile
	Отправьте файл в виде потока октетов.
	res.sendStatus()
	Установите код состояния ответа и отправьте его строковое представление в качестве тела ответа.
	

13.         Пакет Express. Основные принципы работы. Обработка query- и path-параметров GET-запроса. Пример.
Express - это фреймворк для Node.js, который реализовывает слой функций, необходимых для создания эффективных приложений и API. Его использование значительно сокращает написание кода, а, значит, уменьшается затрачиваемое на разработку время.
Node.js Express устанавливается через пакетный менеджер npm.
Node.js Express имеет готовые функции обработки HTTP запросов, причем для каждого HTTP метода имеется своя функция, что особенно удобно при создании REST API. И это далеко не единственная причина использования Express.
Метод use() используется для создания промежуточных обработчиков - Middleware.
Фре́ймворк — программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.
Получение входных параметров от клиента с помощью маршрута
При создании API вы должны позволить пользователям сообщать вам, что они хотят получить от вашего сервиса. Например, если клиент запрашивает информацию о пользователе, хранящемся в базе данных, ему нужен способ сообщить вам, какой пользователь его интересует. Один из возможных способов достижения этого результата - использование параметров маршрута. Параметры маршрута называются сегментами URL-адреса, разделенными косыми чертами (/). Каждый сегмент фиксирует значение той части URL-адреса, которая соответствует его положению. Полученное значение мож
но найти в объекте req.params.
Получение входных параметров от клиента с помощью строки запроса
Другой распространенный способ получения входных данных от клиента - это кодирование данных после пути маршрута с помощью строки запроса (query). Строка запроса отделяется от маршрута вопросительным знаком (?), и включает параметры в виде имя_параметра=значение. Каждый параметр разделен амперсандом (&). Express может анализировать данные из строки запроса и сохранять эти данные в объект req.query. Поэтому, если необходимо узнать значение какого-нибудь параметра, нужно обратиться к объекту req.query, добавив к нему через точку имя_параметра. Например, если нужно получить значение параметра user из вышеприведенного запроса, то необходимо обратиться к req.query.user. Если же обратиться к req.query, то можно получить все параметры строки запроса в виде объекта.


14.         Пакет Express. Основные принципы работы. Обработка тела (form, json) POST-запроса. Пример.
Express - это фреймворк для Node.js, который реализовывает слой функций, необходимых для создания эффективных приложений и API. Его использование значительно сокращает написание кода, а, значит, уменьшается затрачиваемое на разработку время.
Node.js Express устанавливается через пакетный менеджер npm.
Node.js Express имеет готовые функции обработки HTTP запросов, причем для каждого HTTP метода имеется своя функция, что особенно удобно при создании REST API. И это далеко не единственная причина использования Express.
Метод use() используется для создания промежуточных обработчиков - Middleware.
Фре́ймворк — программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.




15.         Пакет Express. Основные принципы работы (методы download и attachment, переадресация). Пример.
Attachment – указание http-клиенту не отображать содержимое body, а сохранить в файловой структуре.




16.         Handlebars. Назначение, использование: шаблоны, макеты, хэлперы, частичные представления.
Handlebars - это шаблонный процессор, который динамически генерирует вашу HTML-страницу, что экономит ваше время на ручном обновлении.
Существуют две основные причины, по которым вы хотите создать шаблон для своего сайта. Прежде всего, создание шаблона побуждает вас отделять логический код от фактического представления, помогая вам придерживаться шаблона View/Controller. Во-вторых, шаблоны сохраняют ваш код чистым и поддерживаемым, что, в свою очередь, делает процесс обновления вашего сайта быстрым. Вы не создаете сайт с Handlebars. Вместо этого вы создаете рекомендации и структуры, которые определяют, как должен выглядеть сайт, не фокусируясь на данных страницы.
Handlebars генерирует ваш HTML, используя структуру JSON и запуская ее через шаблон. Эти шаблоны написаны в основном в обычном HTML и набиты заполнителями, которые позволяют вам при необходимости вводить данные. 
Шаблонизация - механизм генерации текстового на основе готового шаблона. 
Шаблон - статический текст с вкраплениями специальных символов (комбинацией символов), предназначенных для динамической генерации новых фрагментов текста.заебись
Шаблон — это готовая вёрстка страницы или блока, которая состоит только из оформления, и не содержит никакого контента (полезной информации). Шаблон показывает динамическую информацию. Прилагательное «динамическая» означает, что эти данные могут меняться и показываться в зависимости от различных условий.
Контекст шаблона – данные, которые передаются в шаблон.
   
Лейаут (макет) — это шаблон, который содержит HTML-код, общий для всех страниц сайта. В нём могут содержаться подключение стилей, мета-теги, шапка, подвал. Также лейаут содержит область для вставки уникального содержимого каждой страницы.
Нередко вeб-страницы в приложении используют какие-то общие элементы. Это может быть меню, шапка сайта, футер, другие элементы. Однако здесь встает проблема: если потребуется поменять этот общий элемент, то придется вносить изменения на все веб-страницы, которые используют этот элемент. И было бы гораздо проще определить этот элемент в одном месте, а затем подключать на все страницы.
         Решить эту проблему помогают частичные представления (partial views), которые представляют разделяемые общие элементы, которые можно добавлять на обычные представления.
Partials позволяют повторно использовать код путем создания общих шаблонов. Partials — это обычные handlebars-шаблоны, которые могут быть непосредственно вызваны через другие шаблоны.
Хелперы представляют функции, которые возвращают некоторую строку. После получения эту строку можно добавить в любое место представления. Строка может представлять собой в том числе и код html.
Хелперы позволяют оптимизировать создание кода представлений. В частности, мы можем один раз определить функцию хелпера, а затем многократно применять ее в самых различных местах для генерации кода.
Встроенные хелперы:
if — используйте этот хелпер для вывода блока по условию.
unless — используйте этот хелпер как обратный хелперу if. Блок будет выведен, если выражение вернет ложное значение.
each — используйте этот хелпер для перебора списков. Внутри блока Вы можете использовать this для ссылки на элемент списка.
with — используйте этот хелпер для сдвига контекста секции handlebars-шаблона.
log — позволяет логировать состояние контекста во время выполнения шаблона
Как правило, приложения Express для определения визуального интерфейса использует не стандартные файлы html, а специальные сущности - представления, из которых затем создаются html-файлы. Преимуществом представлений является то, что мы можем определять в них некоторые шаблоны, вместо которых затем вставляется какое-то динамическое содержимое с помощью кода javascript.
Управляет представлениями специальный компонент - движок представлений (view engine), который также называют движок шаблонов (template engine). Вообще движков представлений в Express довольно много: Pug, Jade, Dust, Nunjucks, EJS, Handlebars и другие. Вопрос выбора движка представлений - в основном вопрос предпочтений, все они предоставляют схожую функциональность, различаясь лишь в каких-то деталях.
Для работы с движками представлений в Express определено ряд глобальных настроек, которые мы можем установить. Прежде всего это настройка view engine, которая устанавливает используемый движок предствлений, и views, которая устанавливает путь к папке с представлениями внутри проекта (если этот параметр не установлен, то по умолчанию используется папка с именем views).


17.     Пакет Express. Основные принципы работы. Обработка Cookie. Signed cookie. Пример.
What are “signed” cookies in connect/expressjs?
The cookie will still be visible, but it has a signature, so it can detect if the client modified the cookie.


It works by creating a HMAC of the value (current cookie), and base64 encoded it. When the cookie gets read, it recalculates the signature and makes sure that it matches the signature attached to it.


If it does not match, then it will give an error.


If you want to hide the contents of the cookie as well, you should encrypt it instead (or just stores it in the server side session). I'm not sure if there is middleware for that already out there or not.


res.cookie('name', 'value', {signed: true})
req.signedCookies['name']


Пример обычных:
app.use(express.cookieParser());


var cookie = req.cookies.cookieName; 
res.cookie('cookieName',randomNumber, { maxAge: 900000, httpOnly: true }); 
18.         Пакет Express. Основные принципы работы. Применение объекта Session. Пример.
  

Во время инициализации Node.js сессии с помощью объекта можно задать следующие опции:


cookie - настройка cookie хранения идентификатора сессии, передается объект с опциями (подробно здесь);
genid - функция, которая возвращает новый идентификатор сессии в виде строки (по умолчанию используется функция, генерирующая идентификаторы на основе библиотеки uid-safe);
resave - булевое значение, указывает, нужно ли пересохранять сессию в хранилище, если она не изменилась (по умолчанию false);
rolling - булевое значение, указывающее, нужно ли устанавливать идентификатор сессии cookie на каждый запрос (по умолчанию false);
saveUninitialized - булевое значение, если true, то в хранилище будут попадать пустые сессии;
secret - строка, которой подписывается сохраняемый в cookie идентификатор сессии;
store - экземпляр хранилища, которое будет использоваться для хранения сессии (рассмотрено ниже в этой статье).
19.         Аутентификация. Разработка приложения с http-аутентификацией. Пример.
Вопрос №3
20.         Аутентификация. Разработка приложения с digest-аутентификацией. Пример.
Вопрос №3
21.         Аутентификация. Разработка приложения с forms-аутентификацией. Пример.
Вопрос №3
22.         Токен-аутентификация.
  

  

токен можно хранить в памяти приложения /cookie/localStorage/sessionStorage.
        состоит из 3-х частей:
1.     

     2.  
3.  
пример
  

  

23.         OAuth 2.0, OpenID.
 OAuth 2.0: открытый стандарт авторизации
  

  

  

  

  

  

  

OPEN ID
OpenID: открытый стандарт аутентификации, позволяющий реализовать Single Sign-On (технология единого входа). Версии: OpenID 1.1, OpenID 2.0, OpenID Connect 1.0 (над протоколом OAuth). Стандарт можно расширять.
OpenID: генерация цифрового идентификатора для децентрализованного применения.
OpenID:  использует только стандартные HTTP(S)-сообщения; не требуется cookie. 
OpenID: идентификатор в формате HTTP(S) URI или XRI (формат разработанный OASIS).
OpenID: OpenID-провайдер – сервер, хранящий информацию об идентификаторе, подтверждает подлинность идентификатора.
OpenID: интернет-сервис - приложение, которое хочет проверить подлинность OpenID-идентификатора
Возможности OpenID
OpenID позволяет пользователю использовать одну учетную запись, зарегистрированную у OpenID-провайдера, на множестве других сайтов. Пользователь может выбрать, какую информацию предоставить сайту. Обмен информацией профиля или другими сведениями, не описанными в спецификации OpenID, может быть реализован поверх протокола OpenID с помощью дополнительных видов обслуживания. Для этого предусмотрен официально поддерживаемый протоколом OpenID механизм расширения протокола.
Существует возможность делегирования OpenID. Это означает, что владелец некоего доменного имени может использовать его в качестве синонима (алиаса) к уже существующему OpenID-идентификатору, полученному у любого провайдера OpenID. Для этого необходимо на страницу, используемую в качестве делегата, добавить несколько мета-тегов.
Децентрализованность
Система OpenID — децентрализованная система. Это значит, что нет какой-либо центральной службы или организации, которая разрешала бы использование системы или регистрировала бы запрашивающие аутентификацию OpenID интернет-ресурсы или провайдеров OpenID. Конечный пользователь может свободно выбирать, какого провайдера OpenID использовать, и сохранять Идентификатор в случае изменения провайдера OpenID].


24.         Авторизация: виды, реализация.
1. Authorization: процедура предоставления доступа к определенному ресурсу/действию на основании каких-то признаков (флагов, ролей, привилегий и т.д.).
2. Authorization: виды:
а) дискреционное управление доступом (DAC);
б) мандатное управление доступом (MAC);
в) управление доступом на основе ролей (RBAC).
3. Authorization: дискреционное (прямое) управление доступом (DAC): список доступа (ACL) субъектов к объекту (Microsoft Windows, Unix)
Например:
пользователю user_1 разрешено читать файл file_1
пользователю user_2 разрешено читать и писать в файл file_1
 
4. Authorization: мандатное управление доступом (MAC): уровень доступа субъекта ≥ уровень секретности объекта
Например:
пользователю с уровнем доступа L1 разрешено читать файл file_1
 
5. Authorization: управление доступом на основе ролей (RBAC): роль у субъекта, определяющая привилегии относительно объекта (Oracle, Microsoft Active Directory, PostreSQL)
Например:
пользователю с ролью role_1 разрешено читать файл file_1
6. Authorization: роль - набор правил, определяющих, какими привилегиями и по отношению к каким объектам будет обладать пользователь, которому будет назначена эта роль.
7. Authorization: привилегия (операция) — полномочие субъекта относительно какого-то объекта.
пример в 25 вопросе
25.         Библиотеки Node ACL и CASL.
ACL (Access Control Lists):ХЗ не вижу смысла ебашить все методы
This module provides a minimalistic ACL implementation inspired by Zend_ACL.
When you develop a web site or application you will soon notice that sessions are not enough to protect all the available resources. Avoiding that malicious users access other users content proves a much more complicated task than anticipated. ACL can solve this problem in a flexible and elegant way.
Create roles and assign roles to users. Sometimes it may even be useful to create one role per user, to get the finest granularity possible, while in other situations you will give the asterisk permission for admin kind of functionality.
A Redis, MongoDB and In-Memory based backends are provided built-in in the module. There are other third party backends such as knex based, firebase and elasticsearch. There is also an alternative memory backend that supports regexps.
  

  
  
  
  

casl:— это библиотека для авторизации в JavaScript, которая заставляет задумываться о том, что пользователь может делать в системе, а не какую роль он имеет (проверка звучит так: если пользователь имеет эту способность, то он может сделай это).
  
  
  
  
  
  
  
  
  





26.         Сервис Heroku: устройство, ресурсы, функции. Непрерывная интеграция и доставка (CI/CD).
Heroku — облачная PaaS-платформа, поддерживающая ряд языков программирования. С 2010 года является дочерней компанией Salesforce.com[1]. Heroku, одна из первых облачных платформ, появилась в июне 2007 года и изначально поддерживала только язык программирования Ruby, но на данный момент список поддерживаемых языков также включает в себя Java, Node.js, Scala, Clojure, Python, Go, Ruby и PHP. На серверах Heroku используются операционные системы Debian или Ubuntu[2]


27.         Пакет crypto. Основные принципы работы (шифрование, поточное шифрование, алгоритм Диффи-Хеллмана).
в лабе ебёт по ключам(кто закрытый и кто открытый ключ)душила и просила сломать лабу,чтобы 409 ошибка была
О пакете crypto в 28 вопросе.
Шифрование:
  
Поточное Шифрование:  
алгоритм Диффи-Хеллмана: криптографический протокол, позволяющий двум и более сторонам получить общий секретный ключ, используя незащищенный от прослушивания канал связи. Полученный ключ используется для шифрования дальнейшего обмена с помощью алгоритмов симметричного шифрования.  
При работе алгоритма каждая сторона:
   1. генерирует случайное натуральное число a — закрытый ключ
   2. совместно с удалённой стороной устанавливает открытые параметры p и g (обычно значения p и g генерируются на одной стороне и передаются другой), где
p является случайным простым числом
(p-1)/2 также должно быть случайным простым числом (для повышения безопасности)[5]
g является первообразным корнем по модулю p (также является простым числом)
   3. вычисляет открытый ключ A, используя преобразование над закрытым ключом
A = ga mod p
   4. обменивается открытыми ключами с удалённой стороной
   5. вычисляет общий секретный ключ K, используя открытый ключ удаленной стороны B и свой закрытый ключ a
K = Ba mod p
К получается равным с обеих сторон, потому что:
Ba mod p = (gb mod p)a mod p = gab mod p = (ga mod p)b mod p = Ab mod p
В практических реализациях для a и b используются числа порядка 10100 и p порядка 10300. Число g не обязано быть большим и обычно имеет значение в пределах первого десятка.  


28.         Пакет crypto. Основные принципы работы (хэширование, поточное хэширование, hmac).
О пакете crypto
Модуль crypto предоставляет функционал шифрования, который включает в себя набор wrapper'ов для хэша OpenSSL, HMAC, шифраторов, дешифраторов и функций верификации.
Для доступа к этому модулю используйте require('crypto').
Класс Hmac
Класс Hmac является утилитой для создания криптографических дайджестов HMAC. Его можно использовать так:
      * как стрим, который явлется открытым для чтения и записи одновременно, где данные записываются для получения вычисляемого HMAC-дайджеста, или
      * используя методы hmac.update() и hmac.digest() для получения вычисляемого хэша.
Метод crypto.createHmac() используется для создания экземпляров Hmac. Объекты Hmac не создаются непосредственно с помощью ключевого слова new.
crypto.createHmac()
crypto.createHmac(algorithm, key)
Создает и возращает объект Hmac, который использует данные algorithm и key
algorithm зависит от доступных алгоритмов, поддерживаемых версией OpenSSL (примерами являются 'sha256', 'sha512' и т.д.). В последних релизах OpenSSL openssl list-message-digest-algorithms отображает доступные дайджест-алгоритмы.
key является ключом HMAC, используемым для генерации криптографического хэша HMAC.


crypto.createHash()
crypto.createHash(algorithm)
Создает и возвращает объект Hash, который можно использовать для генерации хэш-дайджестов с помощью данного алгоритма.
algorithm зависит от доступных алгоритмов, поддерживаемых версией OpenSSL (примерами являются 'sha256', 'sha512' и т.д.). В последних релизах OpenSSL openssl list-message-digest-algorithms отображает доступные дайджест-алгоритмы.


 Crypto: хеширование
  

  

 Crypto: хеширование поточное
  

  

 Crypto: дайджест, зашифрованный хеш.
  

  

 Crypto: дайджест, зашифрованный хеш, поток.


  

29.         Пакет crypto. Основные принципы работы (цифровая подпись).
Класс Verify
Класс Verify – это утилита для подтверждения подписей. Его можно использовать такими способами:
      * как стрим, который является открытым для записи, где записанные данные используются для валидации подписи, или
      * используя методы verify.update() и verify.verify() для подтверждения подписей.
Метод crypto.createSign() используется для создания экземпляров Sign. Объекты Sign не создаются непосредственно с помощью ключевого слова new.
verifier.verify()
verifier.verify(object, signature[, signature_format])
Подтверждает передаваемые данные, используя заданные object и signature. Аргумент object является строкой, содержащей PEM-кодированный объект, который может быть либо публичным ключом RSA, либо публичным ключом DSA, либо сертификатом X.509. Аргумент signature является предварительно вычисленной подписью для данных в формате signature_format, который может быть latin1, hex, или base64. Если задан signature_format, то signature должен быть строкой, в иных случаях это будет буфер.
Возвращает true или false в зависимости от валидности подписи для данных и публичного ключа.
Объект verifier нельзя использовать снова после вызова метода verify.verify(). Множественные вызовы verify.verify() могут привести к ошибке.




 Crypto: цифровая подпись
  

  

  

30.         Протокол WebDav. Назначение, применение, стандарты, методы. Разработка приложения с применением WebDav.
1. WebDAV: Web Distributed Authoring and Versioning – расширение протокола HTTP/HTTPS, поддерживающее совместную работу по управление файлами на удаленных web-северах; применяется для создания сетевой файловой системы; в системах документооборота (document management system). Описание в RFC 2518 (=>RFC 4918).
 WebDAV: унаследованные HTTP-методы
 WebDAV: GET – скачать файл.
 WebDAV: PUT – загрузить файл на сервер.
 WebDAV: DELETE – удалить серверный объект.
HTTP Request Methods
The following 39 HTTP Request Method values were found in all available webconcepts.infospecifications. Please be advised that the table shown here is maintained and compiled from Web Concepts sources. The official HTTP Request Method registry is maintained by the Internet Assigned Numbers Authority (IANA).
HTTP Request Method
	Specification
	ACL
	RFC 3744: Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol
	BASELINE-CONTROL
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	BIND
	RFC 5842: Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)
	CHECKIN
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	CHECKOUT
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	CONNECT
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	COPY
	RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
	DELETE
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	GET
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	HEAD
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	LABEL
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	LINK
	Internet Draft snell-link-method: HTTP Link and Unlink Methods
	LOCK
	RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
	MERGE
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	MKACTIVITY
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	MKCALENDAR
	RFC 4791: Calendaring Extensions to WebDAV (CalDAV)
	MKCOL
	RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
	MKREDIRECTREF
	RFC 4437: Web Distributed Authoring and Versioning (WebDAV): Redirect Reference Resources
	MKWORKSPACE
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	MOVE
	RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
	OPTIONS
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	ORDERPATCH
	RFC 3648: Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol
	PATCH
	RFC 5789: PATCH Method for HTTP
	POST
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	PRI
	RFC 7540: Hypertext Transfer Protocol Version 2
	PROPFIND
	RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
	PROPPATCH
	RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
	PUT
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	REBIND
	RFC 5842: Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)
	REPORT
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	SEARCH
	RFC 5323: Web Distributed Authoring and Versioning (WebDAV) SEARCH
	TRACE
	RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
	UNBIND
	RFC 5842: Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)
	UNCHECKOUT
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	UNLINK
	Internet Draft snell-link-method: HTTP Link and Unlink Methods
	UNLOCK
	RFC 4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)
	UPDATE
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	UPDATEREDIRECTREF
	RFC 4437: Web Distributed Authoring and Versioning (WebDAV): Redirect Reference Resources
	VERSION-CONTROL
	RFC 3253: Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)
	Википедия:WebDAV расширяет HTTP следующими методами запроса:
      * PROPFIND — получение свойств объекта на сервере в формате XML. Также можно получать структуру репозитория (дерево каталогов);
      * PROPPATCH — изменение свойств за одну транзакцию;
      * MKCOL — создать коллекцию объектов (каталог в случае доступа к файлам);
      * COPY — копирование из одного URI в другой;
      * MOVE — перемещение из одного URI в другой;
      * LOCK — поставить блокировку на объекте. WebDAV поддерживает эксклюзивные и общие (shared) блокировки;
      * UNLOCK — снять блокировку с ресурса.


 WebDav: client, create Directory, delete File 
  

 WebDav: download file
  

 WebDav: сервер, File System mapping
  

 WebDav: сервер, middleware
  

 WebDav: сервер, аутентификация, авторизация
  

 WebDav: клиент, аутентификация
  

31.         Протокол JSON-RPC. Назначение, структура запроса, структура ответа. Разработка клиент-серверного приложения, использующего протокол JSON-RPC. Пример.
 JSON-RPC - протокол удаленного вызова процедур, использующий формат JSON для передачи сообщений. Это очень простой протокол (очень похожий на XML-RPC), определяющий только несколько типов данных и команд. JSON-RPC поддерживает уведомления (информация, отправляемая на сервер, не требует ответа) и множественные вызовы.
JSON-RPC работает, посылая запросы к серверу, реализующему протокол. Клиентом обычно является программа, которой нужно вызвать метод на удалённой системе. Множество входных параметров может быть передано удалённому методу как массив или запись. Метод также может вернуть множество выходных данных (это зависит от реализации). Удалённый метод вызывается отправлением запроса на удалённый сервер посредством HTTP или TCP/IP-сокета (начиная с версии 2.0). При использовании HTTP заголовок Content-Type определяется как application/json.
Все передаваемые данные — простые записи, сериализованные в JSON. Запрос — вызов определённого метода, предоставляемого удалённой системой. Он должен содержать три обязательных свойства:
·           method — строка с именем вызываемого метода.
·           params — массив данных, которые должны быть переданы методу, как параметры.
·           id — значение любого типа, которое используется для установки соответствия между запросом и ответом.
Сервер должен отослать правильный ответ на каждый полученный запрос. Ответ должен содержать следующие свойства:
·           result — данные, которые вернул метод. Если произошла ошибка во время выполнения метода, это свойство должно быть установлено в null.
·           error — код ошибки, если произошла ошибка во время выполнения метода, иначе null.
·           id — то же значение, что и в запросе, к которому относится данный ответ.
  

Для ситуаций, когда ответ не требуется, были введены уведомления. Уведомление отличается от запроса отсутствием свойства id, которое не требуется, так как не будет передан ответ. В таком случае свойство id может быть пропущено (версия 2.0) или установлено в null (версия 1.0).


Что такое пакет RPC-запросов? 
Чтобы отправить несколько объектов Запроса одновременно, Клиент МОЖЕТ отправить массив, заполненный объектами запроса.
Сервер должен ответить Массивом, содержащим соответствующие объекты ответа, после обработки всех объектов пакетного запроса. Объект ответа ДОЛЖЕН существовать для каждого объекта запроса, за исключением того, что НЕ ДОЛЖНО быть никаких объектов ответа для уведомлений. Сервер МОЖЕТ обрабатывать пакетный вызов rpc как набор параллельных задач, обрабатывая их в любом порядке и с любой шириной параллелизма.
Объекты ответа, возвращаемые из пакетного вызова, МОГУТ быть возвращены в любом порядке внутри массива. Клиент ДОЛЖЕН сопоставлять контексты между набором объектов запроса и результирующим набором объектов ответа на основе элемента id внутри каждого объекта.
Если сам пакетный вызов rpc не распознается как допустимый JSON или массив хотя бы с одним значением, ответ Сервера ДОЛЖЕН быть одним объектом ответа. Если в массиве ответов нет объектов ответа, которые должны быть отправлены клиенту, сервер НЕ ДОЛЖЕН возвращать пустой массив и вообще ничего не должен возвращать.
Позиционные параметры запроса.
  

Передается массив, параметры можно доставать по номеру
  Именованные параметры запроса.
  
Каждому параметру присваивается свое имя, по которому можно к нему обратиться




32.         WASM. Назначение, принципы использования, emcc. Разработка клиент-серверного приложения с применением WASM на стороне браузера. Пример(WasmFiddle-компиляция).
WebAssembly – бинарный формат исполняемого файла, который может исполняться в JavaScript Engine (виртуальная стековая машина).


код быстрее, чем JS; поддерживается большинством браузеров; выполняется в sandbox; есть отладчики; открытый стандарт.


emcc - компилятор с языка C на wasm.
Написали код на C скомпили его в wasm. Затем запускаем его в браузере и радуемся жизни.
  

________________


Да кто такой этот ваш wasm и зачем он нужен?
Смотрите ниже:
  



Разработка на стороне браузера:
  

Как говориться: “Изи пизи лемон сквизи”






Пример WasmFiddle-компиляции:
Переходим по ссылке и нас встречает интерфейс, где справа мы пишем код на C, слева экспортируем функцию, написанную нами, и запускаем ее. “ИЗИ ПИЗИ”
33.         WASM. Назначение, принципы использования, emcc. Разработка клиент-серверного приложения с применением WASM на стороне сервера Node.js. Пример(WasmFiddle-компиляция).
На стороне сервера Node.js все так же легко, как и в браузере.
  



ИЗИ ПИЗИ. Я же говорил!
34.     Telegram Bot. Long pooling, webhook, принцип работы.
         Боты - это сторонние приложения, которые работают внутри Telegram. Пользователи могут взаимодействовать с ботами, отправляя им сообщения, команды и встроенные запросы.
Что я могу сделать с ботами?
Чтобы назвать только несколько вещей, вы могли бы использовать ботов для:
      * Получайте индивидуальные уведомления и новости. Бот может действовать как умная газета, отправляя вам соответствующий контент, как только он будет опубликован.
      * Интеграция с другими сервисами. Бот может обогатить Telegram-чаты контентом из внешних сервисов.
      * Принимайте платежи от пользователей Telegram. Бот может предлагать платные услуги или работать как виртуальная витрина магазина.
      * Создание пользовательских инструментов. Бот может предоставлять вам оповещения, прогнозы погоды, переводы, форматирование или другие услуги.
      * Создавайте одиночные и многопользовательские игры. Бот может предложить богатый опыт HTML5-от простых аркад и головоломок до 3D-шутеров и стратегических игр в реальном времени.
      * Стройте социальные службы. Бот может связывать людей, ищущих собеседников на основе общих интересов или близости.
      * Делайте практически все остальное. За исключением посуды — боты ужасно умеют мыть посуду.
Как работают боты?
По сути, Telegram-боты-это специальные учетные записи, для настройки которых не требуется дополнительный номер телефона. Пользователи могут взаимодействовать с ботами двумя способами:
      * Отправляйте сообщения и команды ботам, открывая с ними чат или добавляя их в группы.
      * Отправляйте запросы непосредственно из поля ввода, набрав @username бота и запрос. Это позволяет отправлять контент от встроенных ботов непосредственно в любой чат, группу или канал.
Сообщения, команды и запросы, отправляемые пользователями, передаются программному обеспечению, работающему на ваших серверах. Наш посреднический сервер обрабатывает все шифрование и связь с Telegram API за вас. Вы общаетесь с этим сервером через простой HTTPS-интерфейс, который предлагает упрощенную версию Telegram API. Мы называем этот интерфейс нашим Бот-API.
BotFather-это единственный бот, который управляет ими всеми. Это поможет вам создавать новых ботов и изменять настройки существующих.
Создание нового бота
Используйте команду /newbot для создания нового бота. Бот-отец запросит у вас имя и имя пользователя, а затем сгенерирует токен авторизации для вашего нового бота.
Имя вашего бота отображается в контактных данных и в других местах.
Имя пользователя-это короткое имя, которое будет использоваться в упоминаниях и t.me ссылки. Имена пользователей имеют длину 5-32 символа и не учитывают регистр, но могут включать только латинские символы, цифры и подчеркивания. Имя пользователя вашего бота должно заканчиваться на "бот", например "tetris_bot" или "TetrisBot".
Токен-это строка 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw, которая необходима для авторизации бота и отправки запросов в API бота. Держите свой токен в безопасности и храните его безопасно, он может быть использован любым человеком для управления вашим ботом.
Генерация маркера авторизации
Если ваш существующий токен скомпрометирован или вы потеряли его по какой-то причине, используйте команду /token для создания нового.
Команды Botfather
Остальные команды довольно понятны:
/mybots — возвращает список ваших ботов с удобными элементами управления для редактирования их настроек
/mygames — делает то же самое для ваших игр
Редактировать ботов
/setname – измените имя вашего бота.
/setdescription — изменение описания бота , краткого текста до 512 символов, описывающего вашего бота. Пользователи увидят этот текст в начале разговора с ботом под названием " Что может сделать этот бот?".
/setabouttext — изменение информации бота, еще более короткий текст до 120 символов. Пользователи увидят этот текст на странице профиля бота. Когда они делятся своим ботом с кем-то, этот текст отправляется вместе со ссылкой.
/setuserpic — изменение фотографий профиля бота. Всегда приятно подставлять лицо под имя.
/setcommands — изменение списка команд, поддерживаемых вашим ботом. Пользователи будут видеть эти команды как предложения, когда они набирают /текст в чате с вашим ботом. Каждая команда имеет имя (должно начинаться с косой черты ‘/’, буквенно-цифровой плюс подчеркивание, не более 32 символов, без учета регистра), параметры и текстовое описание. Пользователи будут видеть список команд всякий раз, когда они наберут " / " в разговоре с вашим ботом.
/deletebot — удалите своего бота и освободите его имя пользователя.
Изменить настройки
/setinline — переключение встроенного режима для вашего бота.
/setinlinegeo - запрос данных о местоположении для предоставления встроенных результатов на основеместоположения .
/setjoingroups — переключает, можно ли добавить вашего бота в группы или нет. Любой бот должен уметь обрабатывать личные сообщения, но если ваш бот не был предназначен для работы в группах, вы можете отключить эту функцию.
/setprivacy — установите, какие сообщения будет получать ваш бот при добавлении в группу. При отключенном режиме конфиденциальности бот будет получать все сообщения. Мы рекомендуем оставить режим конфиденциальности включенным. Вам нужно будет повторно добавить бота в существующие группы, чтобы это изменение вступило в силу.
2 общих подхода для создания бота (web hook; long pool запрос)
Длинные опросы – это самый простой способ поддерживать постоянное соединение с сервером, не используя при этом никаких специфических протоколов (типа WebSocket или Server Sent Events).
Частые опросы
Самый простой способ получать новую информацию от сервера – периодический опрос. То есть, регулярные запросы на сервер вида: «Привет, я здесь, у вас есть какая-нибудь информация для меня?». Например, раз в 10 секунд.
В ответ сервер, во-первых, помечает у себя, что клиент онлайн, а во-вторых посылает весь пакет сообщений, накопившихся к данному моменту.
Это работает, но есть и недостатки:
Сообщения передаются с задержкой до 10 секунд (между запросами).
Даже если сообщений нет, сервер «атакуется» запросами каждые 10 секунд, даже если пользователь переключился куда-нибудь или спит. С точки зрения производительности, это довольно большая нагрузка.
Так что, если речь идёт об очень маленьком сервисе, подход может оказаться жизнеспособным, но в целом он нуждается в улучшении.
Длинные опросы
«Длинные опросы» – гораздо лучший способ взаимодействия с сервером.
Они также очень просты в реализации, и сообщения доставляются без задержек.
Как это происходит:
1.     Запрос отправляется на сервер.
2.    Сервер не закрывает соединение, пока у него не возникнет сообщение для отсылки.
3.    Когда появляется сообщение – сервер отвечает на запрос, посылая его.
4.      Браузер немедленно делает новый запрос.
Для данного метода ситуация, когда браузер отправил запрос и удерживает соединение с сервером, ожидании ответа, является стандартной. Соединение прерывается только доставкой сообщений.
Если соединение будет потеряно, скажем, из-за сетевой ошибки, браузер немедленно посылает новый запрос.
  

 Long Polling — это технология, которая позволяет получать данные о новых событиях с помощью «длинных запросов». Сервер получает запрос, но отправляет ответ на него не сразу, а лишь тогда, когда произойдет какое-либо событие (например, придёт новое сообщение), либо истечет заданное время ожидания.


В сфере веб-разработки наряду с API распространилось понятие вебхук. Рост популярности этого стандарта связан с тем, что всё больше действий в вебе можно описать в терминах событий. Триггерами, запускающими вебхук, могут служить, например, отправка кода в репозиторий или публикация комментария.
Вебхук – это механизм оповещения о происходящих в системе событиях посредством функций обратных вызовов. Когда случается интересующее клиента событие, сервер отправляет HTTP-запрос на URL-адрес, предоставленный клиентом для приема вебхуков.
Данный механизм, используемый веб-приложениями или сайтами, применяется для оповещения о произошедших событиях. Как только что-то произошло (например, пользователь изменил свои настройки, удалил полученное сообщение, оставил комментарий…), отсылается соответствующее уведомление. Благодаря этому отпадает необходимость постоянно запрашивать сервер о произошедших событиях. Достаточно лишь указать, куда именно должны отправляться такие уведомления и они будут приходить сразу же, как произойдёт определённое событие.
Именно в отсутствии необходимости отправлять постоянные запросы и заключается преимущество webhook перед API. Можно сказать так – «не нужно меня постоянно спрашивать, случилось что-то или нет, как только случится, я сам тебе об этом сообщу». Естественно, что это очень простое объяснение, но саму суть оно передаёт.
Можно также сделать так, чтобы события в одной системе не просто приводили к отправке уведомлений, но вызывали изменения в другой системе. И это активно используется при интеграциях. 
Впервые термин webhook был использован в 2007 году. Он появился благодаря программисту Джеффу Линдсею, который адаптировал другой компьютерный термин – «hook» (в русском языке используется слово «перехват»), описывающий технологию для внесения изменений в стандартное поведение системы.